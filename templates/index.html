<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Transcribe API — Мониторинг и загрузка</title>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body class="dark">
    <div class="container">
        <h1>Transcribe API</h1>
        <section class="upload-section">
            <h2>Загрузить аудио/видеофайл для транскрибации</h2>
            <form id="upload-form">
                <div class="form-row">
                    <label>
                        Аудио/Видеофайлы <span style="color:#ffd580">*</span><br>
                        <small>Можно выбрать сразу несколько файлов (mp3, wav, ogg, m4a, flac, mp4, avi, mov, mkv, webm). Из видео будет извлечено аудио.</small>
                    </label>
                    <input id="file-input" type="file" name="file" accept=".mp3,.wav,.ogg,.m4a,.flac,.mp4,.avi,.mov,.mkv,.webm" multiple required>
                    <div id="drop-zone" style="margin-top:8px; padding:14px; border:1px dashed #444; border-radius:7px; color:#b6b6b6; text-align:center; cursor:pointer;">
                        Перетащите файлы сюда или кликните, чтобы выбрать
                    </div>
                    <div id="selected-files" style="margin-top:6px; color:#8be9fd; font-size:0.95em;"></div>
                </div>
                <div class="form-row">
                    <label>
                        Модель Whisper<br>
                        <small>Выберите модель для распознавания речи. Чем больше модель — тем выше качество, но дольше обработка.</small>
                    </label>
                    <select name="model_name">
                        <option value="tiny">tiny</option>
                        <option value="base" selected>base</option>
                        <option value="small">small</option>
                        <option value="medium">medium</option>
                        <option value="large-v2">large-v2</option>
                        <option value="large-v3">large-v3</option>
                    </select>
                </div>
                <div class="form-row">
                    <label>
                        Промт (подсказка)<br>
                        <small>Фразы, слова или контекст, которые помогут Whisper корректно транскрибировать речь (необязательно).</small>
                    </label>
                    <input type="text" name="initial_prompt" placeholder="Например: 'Здравствуйте, меня зовут...'">
                </div>
                <div class="form-row">
                    <label>
                        Скорость (x)<br>
                        <small>Во сколько раз ускорить запись перед транскрибацией. Например, 1.0 — без изменений, 1.5 — ускорить в 1.5 раза.</small>
                    </label>
                    <input type="number" step="0.1" min="0.5" max="3" name="up_speed" value="1.0" placeholder="1.0">
                </div>
                <div class="form-row checkbox-row">
                    <label>
                        <input type="checkbox" name="upgrade_transcribation">
                        Улучшить через GPT<br>
                        <small>Использовать нейросеть для исправления ошибок и улучшения читабельности текста.</small>
                    </label>
                </div>
                <div class="form-row checkbox-row">
                    <label>
                        <input type="checkbox" id="split-roads-checkbox" name="split_roads_enable">
                        Разделить на дорожки<br>
                        <small>Если включено, файл будет разделён на несколько дорожек (ролей).</small>
                    </label>
                </div>
                <div id="split-roads-fields" style="display:none; margin-bottom:10px;">
                    <div class="form-row">
                        <label>Количество дорожек (ролей): <input type="number" id="split-roads-count" min="2" max="8" value="2" style="width:60px;"></label>
                    </div>
                    <div id="split-roads-names"></div>
                </div>
                <div class="action-row">
                    <button type="submit">Отправить</button>
                    <a href="/completed" class="button-like">Готовые</a>
                </div>
            </form>
            <div id="transcribe-status" class="status"></div>
            <pre id="transcribe-result" class="result"></pre>
        </section>
        <section>
            <h2>Webhook таймер</h2>
            <div id="webhook-timer" class="panel"></div>
        </section>
        <section>
            <h2>Статус загрузки моделей</h2>
            <div id="model-status" class="panel"></div>
        </section>
        <section>
            <h2>Статус GPU</h2>
            <div id="gpu-info" class="panel"></div>
        </section>
        <section>
            <h2>Очередь задач</h2>
            <div id="queue" class="panel"></div>
        </section>
        <section>
            <h2>Логи событий</h2>
            <div id="logs" class="panel"></div>
        </section>
    </div>
    <script>
        // Загрузка файла и получение результата
        // --- Split roads UI ---
        const splitCheckbox = document.getElementById('split-roads-checkbox');
        const splitFields = document.getElementById('split-roads-fields');
        const splitCount = document.getElementById('split-roads-count');
        const splitNames = document.getElementById('split-roads-names');
        const modelSelect = document.querySelector('select[name="model_name"]');
        const fileInput = document.getElementById('file-input');
        const dropZone = document.getElementById('drop-zone');
        const selectedFiles = document.getElementById('selected-files');

        function updateRoleFields() {
            const n = parseInt(splitCount.value) || 2;
            splitNames.innerHTML = '';
            for (let i = 0; i < n; ++i) {
                const inp = document.createElement('input');
                inp.type = 'text';
                inp.placeholder = 'Роль ' + (i+1);
                inp.name = 'split_role_' + i;
                inp.style = 'margin-right:8px; margin-bottom:4px; width:120px;';
                if (splitCheckbox.checked) inp.required = true;
                splitNames.appendChild(inp);
            }
        }
        splitCheckbox.addEventListener('change', function() {
            splitFields.style.display = this.checked ? '' : 'none';
            for (let i = 0; i < splitNames.children.length; ++i) {
                splitNames.children[i].value = '';
                if (this.checked) {
                    splitNames.children[i].required = true;
                } else {
                    splitNames.children[i].required = false;
                }
            }
        });
        splitCount.addEventListener('input', updateRoleFields);
        updateRoleFields();

        // --- Populate model list from backend config (only models from config.py) ---
        async function loadModelOptions() {
            try {
                const status = await fetch('/api/model_status').then(r=>r.json());
                const models = Object.keys(status);
                if (!models || !models.length) return;
                const current = modelSelect.value;
                modelSelect.innerHTML = '';
                for (const name of models) {
                    const opt = document.createElement('option');
                    opt.value = name;
                    opt.textContent = name;
                    modelSelect.appendChild(opt);
                }
                // try keep previous selection, else select first
                if (models.includes(current)) {
                    modelSelect.value = current;
                } else {
                    modelSelect.value = models[0];
                }
            } catch (e) {
                // ignore, keep default options
            }
        }
        loadModelOptions();

        // --- Submit handler ---
        let isUploading = false;
        document.getElementById('upload-form').onsubmit = async function(e) {
            e.preventDefault();
            const statusEl = document.getElementById('transcribe-status');
            const resultEl = document.getElementById('transcribe-result');
            if (isUploading) return; // guard
            statusEl.textContent = '';
            resultEl.textContent = '';

            const files = fileInput.files;
            if (!files || !files.length) {
                statusEl.textContent = 'Файлы не выбраны';
                return;
            }

            // Считываем значения формы ДО отключения элементов
            const formEl = document.getElementById('upload-form');
            const formFD = new FormData(formEl);
            const modelNameVal = formFD.get('model_name');
            const initialPromptVal = formFD.get('initial_prompt') || '';
            const upSpeedVal = formFD.get('up_speed') || '1.0';
            const upgradeChecked = !!formEl.querySelector('input[name="upgrade_transcribation"]').checked;

            // disable UI while processing
            isUploading = true;
            const submitBtn = this.querySelector('button[type="submit"]');
            const controls = [submitBtn, fileInput, modelSelect, this.querySelector('input[name="initial_prompt"]'), this.querySelector('input[name="up_speed"]'), this.querySelector('input[name="upgrade_transcribation"]')];
            controls.forEach(el=>{ if(el){ el.disabled = true; el.style.opacity = 0.7; }});
            dropZone.style.pointerEvents = 'none';
            dropZone.style.opacity = '0.6';

            // Подготовка split_roads
            let split_roads_val = null;
            if (splitCheckbox.checked) {
                const n = parseInt(splitCount.value) || 2;
                let split_roads = n + '';
                for (let i = 0; i < n; ++i) {
                    const val = splitNames.children[i].value.trim() || ('Роль'+(i+1));
                    split_roads += ',' + val;
                }
                split_roads_val = split_roads;
            }

            async function uploadOne(file){
                const fd = new FormData();
                // Передаём заранее считанные значения
                if (modelNameVal) fd.append('model_name', modelNameVal);
                if (initialPromptVal) fd.append('initial_prompt', initialPromptVal);
                fd.append('up_speed', upSpeedVal);
                if (upgradeChecked) fd.append('upgrade_transcribation', 'true');
                if (split_roads_val) fd.append('split_roads', split_roads_val);
                fd.append('file', file);

                const resp = await fetch('/api/transcribe', {method: 'POST', body: fd});
                if (!resp.ok) {
                    const t = await resp.text();
                    throw new Error('HTTP ' + resp.status + ': ' + t);
                }
                const data = await resp.json();
                if (!data.task_id) {
                    throw new Error(data.error || 'Ошибка при постановке задачи');
                }
                // Poll until done
                return new Promise((resolve, reject)=>{
                    async function poll(){
                        const r = await fetch('/api/status/' + data.task_id);
                        const s = await r.json();
                        if (s.status === 'done') return resolve(s.result || '');
                        if (s.status === 'error') return reject(new Error(s.error || 'Ошибка'));
                        setTimeout(poll, 1000);
                    }
                    poll();
                });
            }

            statusEl.textContent = `Отправка ${files.length} файлов...`;
            const tasks = Array.from(files).map(async (f, idx)=>{
                try {
                    const text = await uploadOne(f);
                    return {file:f.name, ok:true, text};
                } catch(err){
                    return {file:f.name, ok:false, error: String(err)};
                }
            });
            const results = await Promise.all(tasks);
            const success = results.filter(r=>r.ok).length;
            const failed = results.length - success;
            // show last successful text if any
            const lastOk = results.slice().reverse().find(r=>r.ok);
            if (lastOk) resultEl.innerText = lastOk.text || '';
            statusEl.textContent = `Готово. Успешно: ${success}, Ошибки: ${failed}`;

            // re-enable UI
            controls.forEach(el=>{ if(el){ el.disabled = false; el.style.opacity = ''; }});
            dropZone.style.pointerEvents = '';
            dropZone.style.opacity = '';
            isUploading = false;
        };

        // Drag&drop множественных файлов
        function updateSelectedList(files){
            if(!files || !files.length){ selectedFiles.textContent=''; return; }
            selectedFiles.textContent = Array.from(files).map(f=>f.name).join(', ');
        }
        fileInput.addEventListener('change', ()=>updateSelectedList(fileInput.files));
        dropZone.addEventListener('click', ()=>fileInput.click());
        ;['dragenter','dragover'].forEach(evt=>dropZone.addEventListener(evt, e=>{e.preventDefault(); e.stopPropagation(); dropZone.style.background='#20222a';}));
        ;['dragleave','drop'].forEach(evt=>dropZone.addEventListener(evt, e=>{e.preventDefault(); e.stopPropagation(); dropZone.style.background='';}));
        dropZone.addEventListener('drop', e=>{
            const dt = e.dataTransfer;
            if(dt && dt.files){
                fileInput.files = dt.files;
                updateSelectedList(dt.files);
            }
        });

        // Мониторинг статуса системы
        async function updateAll() {
            const [gpus, queue, logs] = await Promise.all([
                fetch('/api/gpus').then(r=>r.json()),
                fetch('/api/queue').then(r=>r.json()),
                fetch('/api/logs').then(r=>r.json())
            ]);

            document.getElementById('gpu-info').innerHTML = gpus.length
                ? `<table class="gpu-table">
                    <tr>
                        <th>ID</th>
                        <th>Название</th>
                        <th>Память</th>
                        <th>Занято</th>
                        <th>% загрузки</th>
                    </tr>
                    ${gpus.map(g =>
                        `<tr>
                            <td>${g.id}</td>
                            <td>${g.name}</td>
                            <td>${g.memory_total_mb} МБ</td>
                            <td>${g.memory_used_mb} МБ</td>
                            <td>${g.utilization_gpu !== null && g.utilization_gpu !== undefined ? g.utilization_gpu + ' %' : '—'}</td>
                        </tr>`).join('')}
                  </table>`
                : '<div class="empty">Нет доступных GPU</div>';

            document.getElementById('queue').innerHTML = `
                <div class="queue-block">
                    <span>В очереди: <b>${queue.queue.length}</b></span>
                    <span>В обработке: <b>${queue.processing.length}</b></span>
                    <span>Завершено: <b>${queue.completed.length}</b></span>
                    <span>Ошибки: <b>${queue.failed.length}</b></span>
                </div>
                <div class="queue-lists">
                    ${queue.queue.length ? `<div><b>Очередь:</b><ul>${queue.queue.map(t=>`<li>${t.filename} (${t.id.slice(0,8)})</li>`).join('')}</ul></div>` : ''}
                    ${queue.processing.length ? `<div><b>В обработке:</b><ul>${queue.processing.map(t=>`<li>${t.filename} (GPU ${t.gpu_id})</li>`).join('')}</ul></div>` : ''}
                </div>
            `;

            document.getElementById('logs').innerHTML =
                logs.length
                    ? logs.slice().reverse().slice(0,30).map(
                        l=>`<div class="log-line"><span class="log-time">[${l.time.slice(11,19)}]</span> ${l.msg}</div>`
                    ).join('')
                    : '<div class="empty">Логов пока нет</div>';
        }
        setInterval(updateAll, 1000);
        updateAll();

        // Мониторинг загрузки моделей
        async function updateModelStatus() {
            const status = await fetch('/api/model_status').then(r=>r.json());
            let html = '<table class="gpu-table"><tr><th>Модель</th><th>Статус</th></tr>';
            for (const [model, st] of Object.entries(status)) {
                let color =
                    st === "downloaded" ? "#8be9fd" :
                    st === "downloading" ? "#ffd580" :
                    st === "error" ? "#ff5555" : "#b6b6b6";
                html += `<tr>
                    <td>${model}</td>
                    <td style="color:${color};font-weight:600">${st}</td>
                </tr>`;
            }
            html += '</table>';
            document.getElementById('model-status').innerHTML = html;
        }
        setInterval(updateModelStatus, 1000);
        updateModelStatus();

        // Таймер webhook
        async function updateWebhookTimer() {
            const timer = await fetch('/api/webhook_timer').then(r=>r.json());
            let html = '';
            if (!timer.enabled) {
                html = '<span style="color:#aaa">Webhook отключён</span>';
            } else {
                const min = Math.floor(timer.remaining / 60);
                const sec = timer.remaining % 60;
                html = `<b>До вызова webhook:</b> <span style="color:#8be9fd">${min}:${sec.toString().padStart(2,'0')}</span>`;
            }
            document.getElementById('webhook-timer').innerHTML = html;
        }
        setInterval(updateWebhookTimer, 1000);
        updateWebhookTimer();
    </script>
</body>
</html>
